# STM32温湿度采集监测系统 - 从PCB到代码完整实现

## 前言

这是一个基于STM32F103C8T6的温湿度采集监测系统课程设计项目，从PCB设计、电路焊接到程序编写，完整实现了一个具有实时监测、阈值报警、参数设置等功能的嵌入式系统。项目历经多次调试和改进，积累了不少实战经验，特此记录分享。

## 一、项目概述

### 1.1 系统功能

- **实时采集**：使用DHT11传感器采集环境温湿度数据
- **数码管显示**：4位数码管动态扫描显示当前温度/湿度值
- **阈值设置**：支持温度上下限、湿度上下限四个阈值独立设置
- **智能报警**：超出阈值范围时蜂鸣器自动报警
- **按键控制**：实现单击/双击识别，完成菜单切换和参数调节
- **LED指示**：通过LED灯闪烁指示当前工作状态
- **串口通信**：实时回显系统状态和采集数据

### 1.2 硬件清单

| 硬件模块 | 型号/规格 | 说明 |
|---------|----------|------|
| 主控MCU | STM32F103C8T6 | 72MHz主频，64KB Flash |
| 温湿度传感器 | DHT11 | 数字温湿度传感器 |
| 数码管 | 4位共阴极数码管 | 动态扫描显示 |
| 按键 | 4个独立按键 | 支持单击/双击检测 |
| 蜂鸣器 | 无源蜂鸣器 | PWM驱动 |
| LED指示灯 | 2个LED | 状态指示 |
| 串口模块 | USART1 | 调试和数据回显 |

### 1.3 引脚定义

```c
// DHT11温湿度传感器
DHT11_DATA  -> PB8

// 数码管
段选 A-G,DP -> PA0-PA7
位选 DIG1-4 -> PB0, PB1, PB10, PB11

// 按键
KEY1(菜单)  -> PB12
KEY2(切换)  -> PB13
KEY3(增加)  -> PB14
KEY4(减少)  -> PB15

// LED指示灯
LED1        -> PB6
LED2        -> PB7

// 蜂鸣器 (通过TIM3 PWM驱动)
BEEP        -> PA6 (TIM3_CH1)
```

## 二、硬件设计与焊接

### 2.1 PCB设计

这个项目我们使用立创EDA进行PCB设计，主要设计要点：

1. **电源设计**：使用AMS1117-3.3V稳压芯片，为传感器和MCU提供稳定的3.3V电源
2. **晶振电路**：8MHz外部晶振 + 2个22pF电容
3. **复位电路**：10K上拉电阻 + 按键 + 0.1uF滤波电容
4. **下载接口**：预留SWD调试接口（SWDIO、SWCLK、GND、3.3V）

### 2.2 焊接注意事项

**遇到的问题及解决：**

#### 问题1：虚焊导致传感器无响应
- **现象**：DHT11传感器初始化失败，读取数据始终超时
- **排查**：使用万用表测量DHT11的VCC和DATA引脚，发现DATA引脚接触不良
- **解决**：重新焊接DHT11的DATA引脚，确保焊点饱满圆润
- **经验**：对于关键信号引脚，焊接时要确保助焊剂充足，焊锡形成良好的润湿角

#### 问题2：数码管显示不全
- **现象**：数码管只有部分段亮，显示不完整
- **排查**：逐一检查PA0-PA7的焊接情况，发现PA3引脚虚焊
- **解决**：补焊PA3引脚，测试显示正常
- **经验**：焊接密集引脚时，建议使用细烙铁头，避免相邻引脚短路

#### 问题3：按键抖动严重
- **现象**：按键按一次触发多次
- **硬件方案**：为每个按键并联0.1uF电容去抖动
- **软件方案**：在代码中实现按键状态机和延时滤波

## 三、软件架构设计

### 3.1 整体架构

项目采用**任务调度器**架构，实现多任务协同工作：

```c
// 任务列表
task_t sch_task[] = {
    {key_proc,   10,  0},   // 按键扫描 - 10ms
    {seg_proc,   20,  0},   // 数码管显示 - 20ms
    {led_proc,   100, 0},   // LED指示 - 100ms
    {dht11_task, 500, 0},   // 温湿度采集 - 500ms
    {alarm_proc, 500, 0},   // 报警检测 - 500ms
    {uart_proc,  500, 0}    // 串口回显 - 500ms
};
```

### 3.2 模块划分

```
├── user/
│   └── main.c              # 主程序、任务调度器
├── driver/
│   ├── DHT11.c/h           # DHT11驱动
│   ├── led.c/h             # LED驱动
│   ├── key.c/h             # 按键驱动（支持单击/双击）
│   ├── smg.c/h             # 数码管驱动
│   ├── beep.c/h            # 蜂鸣器驱动
│   └── usart.c/h           # 串口驱动
└── system/
    ├── delay.c/h           # 微秒级延时
    ├── timer.c/h           # 定时器配置
    └── sys.c/h             # 系统配置
```

## 四、核心功能实现

### 4.1 DHT11温湿度传感器驱动

DHT11是一个数字温湿度传感器，使用单总线协议通信。驱动实现的难点在于**精确的时序控制**。

#### 关键代码：

```c
// DHT11复位（主机发起信号）
void DHT11_Rst(void)
{
    DHT11_Mode_Out_PP();    // 设置为输出模式
    DHT11_Low();            // 拉低总线

    // 重点：这里必须延时至少18ms！
    // 原始错误代码：delay_us(20); <- 只有0.02ms
    // 正确代码：
    delay_ms(20);           // 延时20ms

    DHT11_High();           // 释放总线
    delay_us(30);           // 等待30us，等待DHT11响应
}
```

#### 遇到的BUG及解决：

**BUG1：DHT11初始化失败**
- **现象**：`DHT11_Check()` 始终返回1，传感器无响应
- **原因**：复位函数中使用了 `delay_us(20)`，实际只延时了0.02毫秒，而DHT11要求主机拉低至少18ms
- **解决**：将 `delay_us(20)` 改为 `delay_ms(20)`
- **教训**：时序敏感的协议，必须仔细阅读数据手册，确认每个延时的单位和时长

**BUG2：读取数据偶尔出错**
- **现象**：温湿度数据偶尔读取异常，显示跳变
- **原因**：DHT11返回的5个字节数据中，最后一个是校验和，需要验证
- **解决**：在 `DHT11_Read_Data()` 中添加校验和验证：
```c
if((buf[0]+buf[1]+buf[2]+buf[3]) == buf[4])
{
    *temp = buf[0];
    *humi = buf[2];
}
```

### 4.2 按键单击/双击识别

按键功能设计：
- **KEY1单击**：温度 ↔ 湿度显示切换
- **KEY1双击**：温度上限 ↔ 温度下限设置切换
- **KEY2单击**：同KEY1单击（备用）
- **KEY2双击**：湿度上限 ↔ 湿度下限设置切换
- **KEY3**：数值增加
- **KEY4**：数值减少

#### 实现思路：

使用**计数器+定时器**方式实现双击检测：

```c
// 双击检测变量
uint8_t k1_click_cnt = 0;   // 按键点击计数
uint16_t k1_timer = 0;      // 按键计时器

// 双击判定时间窗口（调用周期×次数）
#define DOUBLE_CLICK_TIME  30  // 约300ms

void key_proc(void)
{
    // 1. 检测按键按下
    if (Key_Down & 0x01)  // KEY1按下
    {
        k1_click_cnt++;   // 计数+1
        k1_timer = 0;     // 重置计时器

        if (k1_click_cnt == 2)  // 第二次点击
        {
            // 执行双击操作
            if(menu == 2) menu = 3;
            else if(menu == 3) menu = 2;
            else menu = 2;

            k1_click_cnt = 0;  // 重置计数
        }
    }

    // 2. 超时判定为单击
    if (k1_click_cnt == 1)
    {
        k1_timer++;
        if (k1_timer > DOUBLE_CLICK_TIME)
        {
            // 执行单击操作
            if(menu == 0) menu = 1;
            else menu = 0;

            k1_click_cnt = 0;
            k1_timer = 0;
        }
    }
}
```

**调试经验**：
- 双击时间窗口不宜过长（>500ms会误触）也不宜过短（<200ms难操作）
- 建议设置为300-400ms

### 4.3 数码管动态扫描

使用4位共阴极数码管，动态扫描显示。

#### 显示流程：

1. **消隐**：关闭所有位选，防止残影
2. **送段码**：输出当前位的段码（含小数点）
3. **选位**：点亮当前位
4. **延时**：保持一段时间后切换下一位

```c
void SMG_Display_Single(uint8_t pos, uint8_t num, uint8_t dp_en)
{
    // A. 消隐 (防止残影)
    GPIO_ResetBits(GPIOB, GPIO_Pin_0 | GPIO_Pin_1 |
                          GPIO_Pin_10 | GPIO_Pin_11);

    // B. 送段码（叠加小数点）
    uint8_t seg_code = smg_code[num];
    if(dp_en == 1) {
        seg_code |= 0x80;  // 小数点对应PA7
    }
    GPIOA->ODR = (GPIOA->ODR & 0xFF00) | seg_code;

    // C. 选中当前位
    GPIO_SetBits(GPIOB, DIG_PINS[pos]);
}
```

**遇到的问题**：
- **残影问题**：切换位时如果不先消隐，会在相邻位上留下残影
- **解决**：每次更新前先关闭所有位选，再送段码，最后选位

### 4.4 蜂鸣器PWM报警

使用TIM3的PWM功能驱动无源蜂鸣器。

```c
void Init_timer3(void)
{
    // 配置TIM3 CH1 -> PA6
    // 时基：72MHz / 72 / 1000 = 1kHz (1ms周期)
    // ARR = 999, 占空比50%时CCR=500

    TIM_TimeBaseStructure.TIM_Period = 999;
    TIM_TimeBaseStructure.TIM_Prescaler = 71;

    TIM_OCInitStructure.TIM_OCMode = TIM_OCMode_PWM1;
    TIM_OCInitStructure.TIM_Pulse = 0;  // 初始占空比0

    TIM_OC1Init(TIM3, &TIM_OCInitStructure);
}

void alarm_proc(void)
{
    // 只在温度/湿度显示模式下检测报警
    if(menu == 0 || menu == 1)
    {
        if((temp > temp_high || temp < temp_low) ||
           (humi > humi_high || humi < humi_low))
        {
            TIM_SetCompare1(TIM3, 500);  // 50%占空比，开启报警
        }
        else
        {
            TIM_SetCompare1(TIM3, 0);   // 关闭报警
        }
    }
    else
    {
        TIM_SetCompare1(TIM3, 0);  // 设置模式下关闭报警
    }
}
```

## 五、系统工作流程

### 5.1 菜单状态机

```
menu = 0: 显示当前温度
menu = 1: 显示当前湿度
menu = 2: 设置温度上限
menu = 3: 设置温度下限
menu = 4: 设置湿度上限
menu = 5: 设置湿度下限
```

### 5.2 操作流程

1. **上电初始化**：显示温度，LED慢闪
2. **KEY1单击**：温度 ↔ 湿度切换
3. **KEY1双击**：进入温度阈值设置（上限 ↔ 下限）
4. **KEY3/KEY4**：在设置模式下调节阈值
5. **KEY2双击**：进入湿度阈值设置
6. **超出阈值**：蜂鸣器自动报警

## 六、调试技巧与经验总结

### 6.1 调试工具

1. **串口助手**：实时监控系统状态
2. **万用表**：测量电压、检查虚焊
3. **逻辑分析仪**：抓取DHT11通信波形（可选）
4. **示波器**：观察PWM波形（可选）

### 6.2 常见问题排查

| 问题现象 | 可能原因 | 排查方法 |
|---------|---------|---------|
| DHT11无响应 | 1. 虚焊 2. 时序错误 | 检查焊点，确认延时函数 |
| 数码管不亮 | 1. 段码错误 2. 位选未导通 | 逐位测试，检查IO口电平 |
| 按键无反应 | 1. 上拉电阻虚焊 2. IO口配置错误 | 检查按键电压，确认输入模式 |
| 蜂鸣器不响 | 1. PWM未输出 2. 占空比为0 | 示波器测PWM，检查TIM配置 |
| 显示跳变 | 1. 数据采集错误 2. 滤波不足 | 加入校验和，增加软件滤波 |

### 6.3 项目亮点

1. **任务调度器**：采用时间片轮询，避免阻塞，易于扩展
2. **双击识别**：实现单个按键多功能，节省IO口
3. **菜单状态机**：清晰的状态转移逻辑，便于维护
4. **精确时序控制**：DHT11驱动完全符合数据手册要求
5. **完善的错误处理**：校验和验证、超时保护

### 6.4 改进方向

1. **EEPROM存储**：断电保存阈值设置
2. **LCD显示**：更直观的界面显示
3. **历史数据记录**：记录温湿度变化曲线
4. **远程监控**：增加ESP8266 WiFi模块，实现手机APP监控
5. **低功耗优化**：进入休眠模式，降低功耗

## 七、代码组织与规范

### 7.1 代码规范

- 使用有意义的变量名（如 `temp_high` 而非 `th`）
- 关键函数添加注释说明
- 统一缩进（4空格）
- 宏定义使用全大写
- 全局变量使用 `extern` 声明

### 7.2 项目编译

使用Keil uVision5开发环境：
1. 芯片选择：STM32F103C8
2. 时钟配置：外部8MHz，PLL倍频至72MHz
3. 下载器：ST-Link V2
4. 优化等级：O0（调试）/ O2（发布）

## 八、总结与心得

这个项目从硬件到软件，从设计到调试，每一步都是宝贵的学习经历：

1. **硬件焊接**：细节决定成败，虚焊是最常见也是最难发现的问题
2. **时序控制**：嵌入式开发中，精确的时序是很多协议的基础
3. **代码架构**：良好的架构让代码更易维护和扩展
4. **调试方法**：学会使用工具（串口、万用表）快速定位问题
5. **文档意识**：及时记录遇到的问题和解决方案

通过这次课设，不仅掌握了STM32的基本开发流程，更重要的是培养了**工程思维**和**问题解决能力**。

## 附录

### A. 默认配置参数

```c
温度上限：30°C
温度下限：15°C
湿度上限：70%
湿度下限：30%
采集周期：500ms
```

### B. 参考资料

- STM32F103C8T6数据手册
- DHT11传感器数据手册
- Keil MDK开发文档
- 《STM32库开发实战指南》

---

**项目作者**：电信233-刘立烨
**完成时间**：2025年12月
**开源地址**：[GitHub仓库链接]

如果这个项目对你有帮助，欢迎点赞收藏！有问题欢迎在评论区讨论~
